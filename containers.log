The image property of a container supports the same syntax as the docker command does, including private registries and tags

Updating Images:
================

The default pull policy is IfNotPresent which causes the Kubelet to skip pulling an image if it already exists. If you would like to always force a pull, you can do one of the following:

    set the imagePullPolicy of the container to Always.
    omit the imagePullPolicy and use :latest as the tag for the image to use.
    omit the imagePullPolicy and the tag for the image to use.
    enable the AlwaysPullImages admission controller.

Note that you should avoid using :latest tag, see Best Practices for Configuration for more information


kubectl apply -f - <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: private-image-test-1
spec:
  containers:
    - name: uses-private-image
      image: $PRIVATE_IMAGE_NAME
      imagePullPolicy: Always
      command: [ "echo", "SUCCESS" ]
EOF
pod/private-image-test-1 created


Container environment:
=====================

provides several important resources to Containers:

    A filesystem, which is a combination of an image and one or more volumes.
    Information about the Container itself.
    Information about other objects in the cluster.

Container information


Runtime Class;
==============

RuntimeClass is a feature for selecting the container runtime configuration. The container runtime configuration is used to run a Podâ€™s containers.

Set Up:
The RuntimeClass feature gate must be enabled on apiservers and kubelets.

    Configure the CRI implementation on nodes (runtime dependent)
    
        configurations available through RuntimeClass are Container Runtime Interface (CRI) implementation dependent
    
    Create the corresponding RuntimeClass resources
    
        apiVersion: node.k8s.io/v1beta1  # RuntimeClass is defined in the node.k8s.io API group
        kind: RuntimeClass
        metadata:
            name: myclass  # The name the RuntimeClass will be referenced by
        # RuntimeClass is a non-namespaced resource
        handler: myconfiguration  # The name of the corresponding CRI configuration        

Once RuntimeClasses are configured for the cluster, using them is very simple. 
Specify a runtimeClassName in the Pod spec. For example:

apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  runtimeClassName: myclass
  # ...
  
  
Container hooks:
================

There are two hooks that are exposed to Containers:

    PostStart
    
        This hook executes immediately after a container is created. However, there is no guarantee that the hook will execute before the container ENTRYPOINT. No parameters are passed to the handler.

    PreStop
        
        called immediately before a container is terminated due to an API request or management event such as liveness probe failure, preemption, resource contention and others
        
        
Hook handler implementations:

there are two types of hook handlers that can be implemented for Containers

    Exec - Executes a specific command, such as pre-stop.sh
    HTTP - Executes an HTTP request against a specific endpoint on the Container
